<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Chấm Phiếu Trắc Nghiệm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #canvasContainer { position: relative; display: inline-block; }
    canvas { border: 1px solid #ccc; }
    #coords { margin-top: 10px; }
    #btnClear { margin-top: 10px; }
  </style>
  <!-- Sử dụng defer cho OpenCV.js -->
  <script src="https://docs.opencv.org/4.5.2/opencv.js" defer></script>
</head>
<body>
  <h2>Chấm Phiếu Trắc Nghiệm</h2>
  <p>Chọn file ảnh phiếu trắc nghiệm của bạn:</p>
  <input type="file" id="fileInput" accept="image/*">
  <div id="canvasContainer">
    <canvas id="canvasOutput"></canvas>
  </div>
  <div>
    <button id="btnClear">Xoá vùng đã chọn</button>
  </div>
  <div id="coords">
    <h3>Tọa độ vùng đáp án đã chọn:</h3>
    <pre id="coordList"></pre>
  </div>
  <div id="message">Đang tải OpenCV, vui lòng chờ...</div>

  <!-- Đặt mã chính ở cuối body và sử dụng defer để đảm bảo chạy sau OpenCV.js -->
  <script defer>
    let cvReady = false;
    let srcMat = null;
    let cornerPoints = [];
    let answerPoints = [];
    const canvas = document.getElementById('canvasOutput');
    let ctx = canvas.getContext('2d');

    // Hàm khởi tạo khi OpenCV đã sẵn sàng
    function onCvInitialized() {
      cvReady = true;
      document.getElementById('message').innerText = 'OpenCV đã sẵn sàng.';
    }

    // Nếu cv đã tồn tại, gán callback; nếu không, hãy poll đợi
    function waitForCv() {
      if (typeof cv !== 'undefined' && cv.onRuntimeInitialized) {
        cv.onRuntimeInitialized = onCvInitialized;
      } else {
        console.log('Chờ OpenCV...');
        setTimeout(waitForCv, 100);
      }
    }
    waitForCv();

    // Xử lý file upload
    document.getElementById('fileInput').addEventListener('change', function(e) {
      if (!cvReady) {
        alert("OpenCV chưa khởi tạo xong, vui lòng đợi một chút.");
        return;
      }
      let file = e.target.files[0];
      if (!file) return;
      let reader = new FileReader();
      reader.onload = function(event) {
        loadImage(event.target.result);
      }
      reader.readAsDataURL(file);
    });

    // Load ảnh vào canvas và khởi động xử lý
    function loadImage(src) {
      let image = new Image();
      image.onload = function() {
        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);
        if (srcMat) srcMat.delete();
        srcMat = cv.imread(canvas);
        detectCorners();
      }
      image.src = src;
    }

    // Hàm xử lý phát hiện góc bằng OpenCV
    function detectCorners() {
      if (!srcMat) return;
      let gray = new cv.Mat();
      cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
      let blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
      let edges = new cv.Mat();
      cv.Canny(blurred, edges, 50, 150);
      
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      
      let maxArea = 0;
      let approxContour = null;
      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt, false);
        if (area < 1000) { cnt.delete(); continue; }
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * cv.arcLength(cnt, true), true);
        if ((approx.rows === 3 || approx.rows === 4) && area > maxArea) {
          maxArea = area;
          if (approxContour !== null) approxContour.delete();
          approxContour = approx;
        } else {
          approx.delete();
        }
        cnt.delete();
      }
      
      cornerPoints = [];
      if (approxContour) {
        for (let i = 0; i < approxContour.rows; i++) {
          let point = {
            x: approxContour.intAt(i, 0),
            y: approxContour.intAt(i, 1)
          };
          cornerPoints.push(point);
        }
        approxContour.delete();
      }
      
      cv.imshow('canvasOutput', srcMat);
      ctx = canvas.getContext('2d');
      ctx.fillStyle = 'red';
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 3;
      cornerPoints.forEach(pt => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
        ctx.fill();
      });
      
      let msg = cornerPoints.length > 0 ?
        `Đã phát hiện ${cornerPoints.length} điểm góc (tự động). Nếu chưa chính xác, bạn có thể click vào canvas để đánh dấu lại.` :
        'Không phát hiện được điểm góc tự động. Vui lòng click trực tiếp vào các điểm góc trên canvas.';
      document.getElementById('message').innerText = msg;
      
      gray.delete(); blurred.delete(); edges.delete(); hierarchy.delete(); contours.delete();
    }

    // Cho phép người dùng click vào canvas để đánh dấu tọa độ vùng đáp án
    canvas.addEventListener('click', function(e) {
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      ctx.fillStyle = 'blue';
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fill();
      answerPoints.push({ x: Math.round(x), y: Math.round(y) });
      updateCoordList();
    });

    function updateCoordList() {
      let coordList = document.getElementById('coordList');
      coordList.textContent = answerPoints.map((pt, index) => `Điểm ${index+1}: (${pt.x}, ${pt.y})`).join('\n');
    }

    document.getElementById('btnClear').addEventListener('click', function() {
      answerPoints = [];
      updateCoordList();
      if (srcMat) cv.imshow('canvasOutput', srcMat);
      ctx = canvas.getContext('2d');
      ctx.fillStyle = 'red';
      cornerPoints.forEach(pt => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
        ctx.fill();
      });
    });
  </script>
</body>
</html>
